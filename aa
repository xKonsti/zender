#version 410 core

in vec2 rect_pos;
flat in vec2 rect_center;
flat in vec2 rect_size;
flat in vec4 rect_color;
flat in float corner_radius;

uniform vec2 window_size;

out vec4 out_color;

float RoundedRectSDF(vec2 sample_pos, vec2 rect_center, vec2 rect_half_size, float r) {
    vec2 distance2 = abs(rect_center - sample_pos) - rect_half_size + vec2(r, r);
    return 
        min(max(distance2.x, distance2.y), 0.0)  // neg - 0 for inside
        + length(max(distance2, 0.0))               // 0 - pos for outside
        - r;                                        // - r for rounded corners
}

void main() {
    float softness = 1.0;
    float distance = RoundedRectSDF(gl_FragCoord.xy, rect_center / 2, rect_size / 2, corner_radius);
    if (sqrt(dot(gl_FragCoord.xy, rect_center)) < 20) {
        out_color = vec4(0.0, 0.0, 1.0, 1.0);
        return;
    }
    // if (corner_radius == 120) discard;
    // if (distance > 0.0) 
    //     discard;
    // if (corner_radius == 0) discard;
    
    // if (distance > 0) discard;
    float alpha = smoothstep(0.0, softness, distance);

    out_color = vec4(rect_color.rgb, alpha);
}

// void main() {
//     // Convert fragment coords into top-left origin system
//     vec2 fragCoord = vec2(gl_FragCoord.x, window_size.y - gl_FragCoord.y);
//
//     // Rectangle center in window space
//     vec2 rect_center = bottom_left + rect_size * 0.5;
//
//     // Local fragment position relative to rect center
//     vec2 p = fragCoord - rect_center;
//
//     // Half size of rectangle
//     vec2 half_size = rect_size * 0.5;
//
//     // Signed distance to rounded box
//     float dist = sdRoundedBox(p, half_size, corner_radius);
//
//     // Smooth alpha based on distance
//     float aa = fwidth(dist);
//     float alpha = smoothstep(0.0, aa, -dist);
//
//     out_color = vec4(rect_color.rgb, rect_color.a * alpha);
// }
