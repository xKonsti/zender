#version 410 core

in vec4 FragColor;                      // Color from vertex shader
flat in vec2 FragCoord;                      // Window-space coordinates from vertex shader
flat in vec2 RectCenter;                     // Rectangle center from vertex shader
flat in vec2 RectSize;                       // Rectangle size from vertex shader
flat in float CornerRadius;                  // Corner radius from vertex shader
flat in float BorderWidth;                   // Border width from vertex shader
flat in vec4 BorderColor;                    // Border color from vertex shader

out vec4 color;                         // Final output color

float sdRoundedRect(vec2 p, vec2 b, float r) {
    // b = half-size
    vec2 q = abs(p) - b + vec2(r);
    vec2 qpos = max(q, vec2(0.0));
    // distance: outside -> positive, inside -> negative
    return length(qpos) + min(max(q.x, q.y), 0.0) - r;
}

void main() {
    // Calculate position relative to rectangle center
    vec2 p = FragCoord - RectCenter;

    // Calculate half-size of the rectangle
    vec2 halfSize = RectSize * 0.5;

    // Calculate the signed distance to the rounded rectangle
    float r = min(CornerRadius, min(halfSize.x, halfSize.y));
    float d = sdRoundedRect(p, halfSize, r);
    
    // Option 1: Hard discard (uncomment for sharp edges)
    // if (d > 0.0) discard;
    
    // Option 2: Anti-aliased edges (recommended)
    float aa = fwidth(d);

    if (BorderWidth > 0.0) {
        // Render with border
        float outerD = d;
        float innerD = sdRoundedRect(p, halfSize - vec2(BorderWidth), max(0.0, CornerRadius - BorderWidth));
        
        // Discard pixels outside the outer boundary
        if (outerD > aa) discard;
        
        // Anti-aliased border
        float outerAlpha = 1.0 - smoothstep(-aa, aa, outerD);
        float innerAlpha = 1.0 - smoothstep(-aa, aa, innerD);
        float borderAlpha = outerAlpha - innerAlpha;
        
        // Mix fill and border colors
        vec4 fillColor = FragColor;
        vec4 finalColor = mix(fillColor, BorderColor, borderAlpha / max(outerAlpha, 0.001));
        
        color = vec4(finalColor.rgb, finalColor.a * outerAlpha);
    } else {
        // Discard pixels outside the shape (with small tolerance for anti-aliasing)
        // if (d > aa) discard;
        
        // Simple filled rectangle with anti-aliasing
        float alpha = 1.0 - smoothstep(-aa, aa, d);
        color = vec4(FragColor.rgb, FragColor.a * alpha);
    }
}
